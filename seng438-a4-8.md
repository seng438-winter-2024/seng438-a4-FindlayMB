**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#4 â€“ Mutation Testing and Web app testing**

| Group: 8        |
| --------------- |
| Jiawei He       |
| Nicholas Garcia |
| Sarah Qin       |
| Findlay Brown   |

# Introduction
The objective of this assignment is to help us get familarize with mutation testing and GUI testing tools and learn how to utilize these tools to create better test cases to increase the overall testing quality. In this assignment, we will be using PiTest to analyze the mutation scores and Selenium for GUI testing. It is important to come an understanding of what mutation testing is because it helps assessing the effectiveness of the already created test suites. 

# Analysis of 10 Mutants of the Range class

**Range.intersects(double b0, double b1)**

- Mutation: changed (b0 <= this.lower) to (b0 < this.lower) in the if statement
  - Status: SURVIVED
  - Analysis: This mutant survived because b0 values < this.lower are still valid in the b0 <= this.lower condition.
- Mutation: changed return from (b0 < this.upper && b1 >= b0) to false in the else statement, hence the tests still passed.
  - Status: KILLED
  - Analysis: This mutant was killed because changing it to always returning false causes tests to fail where the return statement was supposed to change depending on the conditions.

**Range.constrain(double value)**

- Mutation: changed (value > this.upper) to (value >= this.upper) in the second if statement
  - Status: SURVIVED
  - Analysis: This mutant survived because test values > this.upper are still valid in value >= this.upper, hence the tests still passed.
- Mutation: changed (value > this.upper) to (value <= this.upper) in the second if statement
  - Status: KILLED
  - Analysis: This mutant was killed because the condition is different, causing it to go to the other condtions with a different return value and fails the test.

**Range.expandToInclude(Range range, double value)**

- Mutation: changed (value < range.getLowerBound()) to (value <= range.getLowerBound()) in the second if statement
  - Status: SURVIVED
  - Analysis: This mutant survived because test values < range.getLowerBound() are still valid in values <= range.getLowerBound(), hence the tests still passed.
- Mutation: changed (value < range.getLowerBound()) to (value >= range.getLowerBound()) in the second if statement
  - Status: KILLED
  - Analysis: This mutant was killed because the condition is different, causing it to go to the other condtions with a different return value and fails the test.

**Range.expand(Range range, double lowerMargin, double upperMargin)**

- Mutation: changed (lower > upper) to (lower >= upper) in the if statement
  - Status: SURVIVED
  - Analysis: This mutant survived because test values lower > upper are still valid in lower >= upper, hence the tests still passed.
- Mutation: changed (lower > upper) to (lower <= upper) in the if statement
  - Status: KILLED
  - Analysis: This mutant was killed because the condition is different, causing it to go to the other condtions with a different return value and fails the test.

**Range.shiftWithNoZeroCrossing(double value, double delta)**

- Mutation: changed (value > 0.0) to (value >= 0.0) in the if statement
  - Status: SURVIVED
  - Analysis: This mutant survived because test values > 0.0 are still valid in values >= 0.0, hence the tests still passed.
- Mutation: changed (value > 0.0) to (value <= 0.0) in the if statement
  - Status: KILLED
  - Analysis: This mutant was killed because the condition is different, causing it to go to the other condtions with a different return value and fails the test.

# Report all the statistics and the mutation score for each test class

**Mutation Coverage of Range Before Changes**

![alt text](/images/range_before_changes.png)

**Mutation Coverage of Range After Changes**

![alt text](/images/range_after_changes.png)

**Mutation Coverage of DataUtilities Before Changes**
# TODO 

**Mutation Coverage of Range DataUtilities Changes**
# TODO

# Analysis drawn on the effectiveness of each of the test classes

# A discussion on the effect of equivalent mutants on mutation score accuracy
Since equivalent mutants can not be killed, it decreases the mutation score coverage. This is because an equivalent 
mutant does not actually change the functionality of the original code even though it is syntactically different. Thus, 
our test suites would not be able to kill the mutants. 

# A discussion of what could have been done to improve the mutation score of the test suites
There were a lot of equivalent mutants stemming from if statements where the condition < was changed to <= or vice versa.
Our test cases did not kill these mutants. To improve on the mutation score, we had to alter the source files. Changes 
were made to minimize the amount of equivalent mutants to the point where both class files reached a 100% mutation score
coverage.

# Why do we need mutation testing? Advantages and disadvantages of mutation testing
Mutation testing evaluates software testing effectiveness by introducing mutations to code, helping identify test suite weaknesses, enhance test quality, and improve software reliability. <br>
**Advantages**: can be automated, its systematic, know when to stop, check which test suite is better <br>
**Disadvantages**: can not kill equivalent mutants, there may be an enormous amount of mutants

# Explain your SELENUIM test case design process
The Selenium test cases were designed based on the functionality. For the functions that requires text entry, we tested valid input, invalid input, and inputs with different data type. For example with the login function, we tested it with valid to see if it will prompt the next page and invalid input to see if it displays the incorrect password/email message. To check the functionalty of the button, we tested to see if the correct prompt pops up. An example with the submit button in the register page, the submit button was unclickable when we entered an invalid email and the next step was not prompted. 

# Explain the use of assertions and checkpoints

# how did you test each functionaity with different test data

# Discuss advantages and disadvantages of Selenium vs. Sikulix
The advantage of Selenium is that once you start recording, it will record each step and can rerun that multiple times. 
The advantage of Sikulix is that it uses the image searching to look for the component to perform its actions. We can see the component on the screen before running the test. The disadvantage of both IDE is the syntax. They use different syntax and does not provide many information on how to use it or how to start. 
# How the team work/effort was divided and managed

# Difficulties encountered, challenges overcome, and lessons learned

# Comments/feedback on the lab itself
