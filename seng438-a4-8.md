**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#4 â€“ Mutation Testing and Web app testing**

| Group: 8        |
| --------------- |
| Jiawei He       |
| Nicholas Garcia |
| Sarah Qin       |
| Findlay Brown   |

# Introduction

# Analysis of 10 Mutants of the Range class

**Range.intersects(double b0, double b1)**

- Mutation: changed (b0 <= this.lower) to (b0 < this.lower) in the if statement
  - Status: SURVIVED
  - Analysis: This mutant survived because b0 values < this.lower are still valid in the b0 <= this.lower condition.
- Mutation: changed return from (b0 < this.upper && b1 >= b0) to false in the else statement, hence the tests still passed.
  - Status: KILLED
  - Analysis: This mutant was killed because changing it to always returning false causes tests to fail where the return statement was supposed to change depending on the conditions.

**Range.constrain(double value)**

- Mutation: changed (value > this.upper) to (value >= this.upper) in the second if statement
  - Status: SURVIVED
  - Analysis: This mutant survived because test values > this.upper are still valid in value >= this.upper, hence the tests still passed.
- Mutation: changed (value > this.upper) to (value <= this.upper) in the second if statement
  - Status: KILLED
  - Analysis: This mutant was killed because the condition is different, causing it to go to the other condtions with a different return value and fails the test.

**Range.expandToInclude(Range range, double value)**

- Mutation: changed (value < range.getLowerBound()) to (value <= range.getLowerBound()) in the second if statement
  - Status: SURVIVED
  - Analysis: This mutant survived because test values < range.getLowerBound() are still valid in values <= range.getLowerBound(), hence the tests still passed.
- Mutation: changed (value < range.getLowerBound()) to (value >= range.getLowerBound()) in the second if statement
  - Status: KILLED
  - Analysis: This mutant was killed because the condition is different, causing it to go to the other condtions with a different return value and fails the test.

**Range.expand(Range range, double lowerMargin, double upperMargin)**

- Mutation: changed (lower > upper) to (lower >= upper) in the if statement
  - Status: SURVIVED
  - Analysis: This mutant survived because test values lower > upper are still valid in lower >= upper, hence the tests still passed.
- Mutation: changed (lower > upper) to (lower <= upper) in the if statement
  - Status: KILLED
  - Analysis: This mutant was killed because the condition is different, causing it to go to the other condtions with a different return value and fails the test.

**Range.shiftWithNoZeroCrossing(double value, double delta)**

- Mutation: changed (value > 0.0) to (value >= 0.0) in the if statement
  - Status: SURVIVED
  - Analysis: This mutant survived because test values > 0.0 are still valid in values >= 0.0, hence the tests still passed.
- Mutation: changed (value > 0.0) to (value <= 0.0) in the if statement
  - Status: KILLED
  - Analysis: This mutant was killed because the condition is different, causing it to go to the other condtions with a different return value and fails the test.

# Report all the statistics and the mutation score for each test class

**Mutation Coverage of Range Before Changes**

![alt text](/images/range_before_changes.png)

**Mutation Coverage of Range After Changes**

![alt text](/images/range_after_changes.png)

**Mutation Coverage of DataUtilities Before Changes**
# TODO 

**Mutation Coverage of Range DataUtilities Changes**
# TODO

# Analysis drawn on the effectiveness of each of the test classes

# A discussion on the effect of equivalent mutants on mutation score accuracy
Since equivalent mutants can not be killed, it decreases the mutation score coverage. This is because an equivalent 
mutant does not actually change the functionality of the original code even though it is syntactically different. Thus, 
our test suites would not be able to kill the mutants. 

# A discussion of what could have been done to improve the mutation score of the test suites
There were a lot of equivalent mutants stemming from if statements where the condition < was changed to <= or vice versa.
Our test cases did not kill these mutants. To improve on the mutation score, we had to alter the source files. Changes 
were made to minimize the amount of equivalent mutants to the point where both class files reached a 100% mutation score
coverage.

# Why do we need mutation testing? Advantages and disadvantages of mutation testing

# Explain your SELENUIM test case design process

# Explain the use of assertions and checkpoints

# how did you test each functionaity with different test data

# Discuss advantages and disadvantages of Selenium vs. Sikulix
The advantage of Selenium is that once you start recording, it will record each step and can rerun that multiple times. 
The advantage of Sikulix is that it uses the image searching to look for the component to perform its actions. We can see the component on the screen before running the test. The disadvantage of both IDE is the syntax. They use different syntax and does not provide many information on how to use it or how to start. 
# How the team work/effort was divided and managed

# Difficulties encountered, challenges overcome, and lessons learned

# Comments/feedback on the lab itself
